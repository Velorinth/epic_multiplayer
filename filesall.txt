client\main.py
import arcade
from arcade.camera import Camera2D
import arcade.gui
import os
import time
import threading

from networking.main import start_client, entities
from loader.content import load_content, get_object_properties
from render.renderer import draw, draw_map, initialize_renderer, active_sprites
from game.player import Player
from game.inventory import Inventory
from game.music import MusicPlayer
from entity.entity import Entity, update_entities
from debug.console import DebugConsole

os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

BASE_WIDTH = 960  # 20 tiles * 48 pixels/tile
BASE_HEIGHT = 528 # 11 tiles * 48 pixels/tile

class GameWindow(arcade.Window):
    def __init__(self, width, height, title):
        super().__init__(width, height, title, vsync=True, resizable=True)
        self.set_location(400, 200)
        load_content()
        arcade.set_background_color(arcade.color.BLACK)
        self.mouse_x = 0
        self.mouse_y = 0
        self.camera = Camera2D()
        self.gui_camera = Camera2D()
        self.ui_manager = arcade.gui.UIManager()
        self.ui_manager.enable()
        self.player = Player()
        self.inventory = Inventory()
        self.music_player = MusicPlayer()
        self.console = DebugConsole(self.player, self.inventory, self.ui_manager)

        self.network_thread = threading.Thread(
            target=start_client, args=(self.player,), daemon=True
        )
        self.network_thread.start()

        # Test Entity for offline development
        if not any(e.proto == 'player' for e in entities.values()):
            ent = Entity(id=1, proto="player", x=0, y=0)
            entities[ent.id] = ent
        item1 = Entity(id=2, proto="cheese", x=10, y=0)
        entities[item1.id] = item1
        self.inventory.add_item(item1)
        item1 = Entity(id=3, proto="cheese", x=10, y=2)
        entities[item1.id] = item1
        self.inventory.add_item(item1)
        item1 = Entity(id=4, proto="dirt", x=10, y=0)
        entities[item1.id] = item1
        self.inventory.add_item(item1)
        item1 = Entity(id=5, proto="dirt", x=10, y=2)
        entities[item1.id] = item1
        self.inventory.add_item(item1)
        self.music_player.load_song()
        self.music_player.play()
        print(entities)

    def on_draw(self):
        self.clear()
        
        self.camera.use()
        draw_map(self)
        draw()
        
        self.gui_camera.use()
        self.inventory.draw(self.width, self.height, self.mouse_x, self.mouse_y)
        self.console.draw(self.width, self.height)
        self.ui_manager.draw()    
    def on_update(self, delta_time: float):
        initialize_renderer()
        
        self.player.on_update(delta_time)
        update_entities()

        # Only move the camera if the player is fully linked and ready.
        if self.player.entity:
            player_x, player_y = self.player.get_position()
            
            # This is the correct, backwards-compatible camera logic.
            self.camera.position = (
                player_x,
                player_y,
            )

    def on_resize(self, width: int, height: int):
        super().on_resize(width, height)
        self.camera.match_window()
        self.gui_camera.match_window()
        scale_x = width / BASE_WIDTH
        scale_y = height / BASE_HEIGHT
        self.camera.zoom = max(scale_x, scale_y)
    def on_mouse_motion(self, x: int, y: int, dx: int, dy: int):
        print(x,y)
        self.mouse_x = x; self.mouse_y = y
        if not self.console.is_open:
            self.inventory.on_mouse_motion(x, y, dx, dy)

    def on_mouse_press(self, x: int, y: int, button: int, modifiers: int):
        if not self.console.is_open:
            self.inventory.on_mouse_press(x, y, button, modifiers)

    def on_key_press(self, symbol, modifiers):
        self.console.on_key_press(symbol)

        if not self.console.is_open:
            self.player.on_key_press_player(symbol, modifiers)
            self.inventory.on_key_press_inventory(symbol, modifiers)
    def on_key_release(self, symbol, modifiers):
        if not self.console.is_open:
            self.player.on_key_release_player(symbol, modifiers)
if __name__ == "__main__":
    window = GameWindow(800, 600, "Epic Multiplayer")
    arcade.run()
--------------------
client\debug\console.py
import arcade
import arcade.gui
import io
import contextlib
import traceback

from networking.main import entities
from loader.content import get_objects_by_property
from game.player import Player
from game.inventory import Inventory

# We are keeping this custom widget from the previous attempt.
# Its job is to reliably intercept the Enter key and prevent the default buggy behavior.
class CustomUIInputText(arcade.gui.UIInputText):
    def __init__(self, console_instance, **kwargs):
        super().__init__(**kwargs)
        self.console = console_instance

class DebugConsole:
    FONT_SIZE = 12
    BG_COLOR = (20, 20, 20, 220)
    
    def __init__(self, player_ref: Player, inventory_ref: Inventory, ui_manager: arcade.gui.UIManager):
        self.player = player_ref
        self.inventory = inventory_ref
        self.ui_manager = ui_manager
        self.is_open = False
        
        self.custom_commands = {}
        command_list = get_objects_by_property("type", "cmd")
        for command_data in command_list:
            command_name = command_data.get('command')
            if command_name:
                self.custom_commands[command_name] = command_data

        # Store v_box as an instance variable so we can access it later if needed.
        self.v_box = arcade.gui.UIBoxLayout(size_hint=(1, 1))
        
        self.history_area = arcade.gui.UITextArea(
            text="", size_hint=(1, 1), text_color=arcade.color.WHITE, font_name="Consolas"
        )
        
        self.input_area = CustomUIInputText(
            console_instance=self,
            text="",
            font_size=12,
            text_color=arcade.color.LIGHT_GRAY,
            size_hint=(1, None),
            height=30
        )
        
        # Correct Layout: Add history first so it's on top, then the input area at the bottom.
        self.v_box.add(self.history_area)
        self.v_box.add(self.input_area)

        # Store the main container so we can trigger its render.
        self.container = arcade.gui.UIAnchorLayout(
            children=[self.v_box],
            anchor_x="left", anchor_y="bottom",
            size_hint=(1, 0.5)
        )

    def toggle(self):
        """Shows or hides the console."""
        self.is_open = not self.is_open
        if self.is_open:
            self.ui_manager.add(self.container)
        else:
            self.ui_manager.remove(self.container)

    def on_key_press(self, symbol):
        if symbol == arcade.key.GRAVE:
            self.toggle()
        if self.is_open:
            if symbol == arcade.key.ENTER or symbol == arcade.key.NUM_ENTER:
                self.execute_command()
                return True  # Consume the event
    def draw(self, width, height):
        """Draws the console's background manually."""
        if self.is_open:
            arcade.draw_lrbt_rectangle_filled(0, width, 0, height / 2, self.BG_COLOR)

    def write_line(self, text, color=arcade.color.YELLOW):
        lines = self.history_area.text.split('\n')
        if len(lines) > 200:
            self.history_area.text = '\n'.join(lines[-100:])
        self.history_area.text += f"{text}\n"

    def execute_command(self):
        """Executes the command and forces the UI to redraw."""
        command_text = self.input_area.text.strip()
        print(command_text)
        self.write_line(f"> {command_text}", arcade.color.WHITE)
        self.input_area.text = ""
        self.container.trigger_full_render()

        # Execute the actual command logic after handling the UI updates.
        parts = command_text.split()
        command_name = parts[0]
        if command_name in self.custom_commands:
            self.execute_custom_command(command_name, parts[1:])
        else:
            self.execute_python_command(command_text)
            
    def execute_custom_command(self, name, args):
        command_info = self.custom_commands.get(name)
        self.write_line(f"Executed custom command: '{name}' with args: {args}")
        self.write_line(f"Description: {command_info.get('description', 'N/A')}")
        
    def execute_python_command(self, command):
        console_globals = {
        "arcade": arcade,
        "entities": entities,
        "player": self.player,
        "inventory": self.inventory
        }
        output_buffer = io.StringIO()
        try:
            with contextlib.redirect_stdout(output_buffer):
                exec(command, console_globals)
            output = output_buffer.getvalue().strip()
            if output: self.write_line(output, arcade.color.YELLOW)
        except Exception:
            self.write_line(traceback.format_exc().strip(), arcade.color.RED_ORANGE)
--------------------
client\entity\entity.py
from networking.main import tile_map,entities
from loader.content import get_object_properties as get_content

class Entity:
    def __init__(self,id, x=0, y=0, rot=0, params=None, proto=""):
        self.id = id
        self.x = x
        self.y = y
        self.rot = rot
        self.proto = proto
        self.params = params if params is not None else get_content(self.proto)
        self.dx = 0
        self.dy = 0
        self.dr = 0
        self.sprite = None
        self.draw = True
        self.inventory_id = None
        self.should_update = True

    def set_position(self, x, y):
        self.x = x
        self.y = y
    
    def update(self):
        if self.should_update == True:
            self.x += self.dx  
            self.y += self.dy
            self.rot += self.dr

def get_tile_map():
    return tile_map 

def get_entities():
    return entities 

def update_entities():
    for entity in entities.values():
        entity.update()
--------------------
client\game\inventory.py
import arcade
import collections
import math
from typing import Optional, List, Dict, Any
from entity.entity import Entity

from render.renderer import loaded_textures
from networking.main import entities

class Inventory:
    # --- UI Constants ---
    SLOT_SIZE = 52
    SLOT_MARGIN = 8
    SPRITE_SCALE_FACTOR = 0.6
    HOTBAR_SLOT_COUNT = 5
    SLOT_BG_COLOR = (50, 50, 50, 180)
    SLOT_HIGHLIGHT_COLOR = arcade.color.WHITE
    
    INV_WINDOW_COLOR = (30, 30, 30, 220)
    INV_WINDOW_PADDING = 15
    INV_COLS = 5
    INV_MIN_ROWS = 3
    
    TEXT_COLOR = arcade.color.WHITE
    FONT_SIZE = 12
    
    TOOLTIP_COLOR = (0, 0, 0, 230)
    TOOLTIP_WIDTH = 200

    def __init__(self):
        # The inventory's own master list of entity objects it contains.
        self._master_item_list: list[Entity] = []

        self.cursor_stack: list[Entity] = []
        self.hotbar_slots: list[list[Entity]] = [[] for _ in range(self.HOTBAR_SLOT_COUNT)]
        
        self.selected_hotbar_slot = 0
        self.is_open = False

        self.cursor_sprite = arcade.Sprite()
        self.cursor_sprite_list = arcade.SpriteList()
        self.cursor_sprite_list.append(self.cursor_sprite)

        self.hovered_item_stack: Optional[list[Entity]] = None
        self.mouse_x, self.mouse_y = 0, 0
        self._shape_list = arcade.shape_list.ShapeElementList()
        self._sprite_list = arcade.SpriteList()
        self._text_list = []
        self._clickable_areas = {}
        self._needs_rebuild = True
        
    def _get_entity_hash(self, entity: Entity) -> str:
        param_string = str(sorted(entity.params.items()))
        return f"{entity.proto}:{param_string}"

    def _update_cursor_sprite(self):
        texture_to_use = loaded_textures.get("ui/trans1.png")
        if self.cursor_stack:
            texture_name = self.cursor_stack[0].params.get("texture")
            if texture_name and texture_name in loaded_textures:
                texture_to_use = loaded_textures[texture_name]
        
        if texture_to_use:
            self.cursor_sprite.texture = texture_to_use
            self.cursor_sprite.width = self.SLOT_SIZE * self.SPRITE_SCALE_FACTOR * 1.5
            self.cursor_sprite.height = self.SLOT_SIZE * self.SPRITE_SCALE_FACTOR * 1.5
        else:
            self.cursor_sprite.texture = None

    def add_item(self, entity: Entity):
        """Claims an entity by flagging it and adding it to the internal list."""
        if not entity: return
        entity.inventory_id = 1
        entity.draw = False
        self._master_item_list.append(entity)
        self._needs_rebuild = True

    def drop_stack(self, stack: list, player_entity: Entity):
        """Drops a stack of items, removing them from inventory control."""
        if not stack: return
        
        stack_ids = {id(item) for item in stack}
        self._master_item_list = [item for item in self._master_item_list if id(item) not in stack_ids]

        for item in stack:
            item.inventory_id = None
            item.draw = True
            item.x = player_entity.x
            item.y = player_entity.y
        
        stack.clear()
        self._needs_rebuild = True

    def on_key_press_inventory(self, symbol, modifiers):
        if symbol == arcade.key.TAB:
            self.is_open = not self.is_open
            self._needs_rebuild = True
        if arcade.key.KEY_1 <= symbol <= arcade.key.KEY_5:
            self.selected_hotbar_slot = symbol - arcade.key.KEY_1
            self._needs_rebuild = True

    def on_mouse_motion(self, x: int, y: int, dx: int, dy: int):
        self.mouse_x, self.mouse_y = x, y
        self.hovered_item_stack = None
        
        current_areas = self._clickable_areas if self.is_open else {k: v for k, v in self._clickable_areas.items() if k[0] == 'hotbar'}
        for area_id, area_rect in current_areas.items():
            left, bottom, width, height = area_rect
            if left < x < left + width and bottom < y < bottom + height:
                area_type, data = area_id
                if area_type == "hotbar" and self.hotbar_slots[data]:
                    self.hovered_item_stack = self.hotbar_slots[data]
                elif area_type == "inventory":
                    grouped_items = self._get_grouped_items()
                    if data < len(grouped_items):
                        self.hovered_item_stack = grouped_items[list(grouped_items.keys())[data]]
                break

    def on_mouse_press(self, x: int, y: int, button: int, modifiers: int):
        clicked_area = None
        for area_id, area_rect in self._clickable_areas.items():
            left, bottom, width, height = area_rect
            if left < x < left + width and bottom < y < bottom + height:
                clicked_area = area_id; break
        if not clicked_area: return

        area_type, data = clicked_area
        
        if area_type == "hotbar":
            self._handle_hotbar_click(data, button)
        elif area_type == "inventory" and self.is_open:
            self._handle_inventory_click(data, button)

        self._update_cursor_sprite()
        self._needs_rebuild = True
    
    def _handle_hotbar_click(self, slot_index: int, button: int):
        target_stack = self.hotbar_slots[slot_index]
        if button == arcade.MOUSE_BUTTON_LEFT:
            # Check if both cursor and target stacks have items and are of the same type
            if self.cursor_stack and target_stack and self._get_entity_hash(self.cursor_stack[0]) == self._get_entity_hash(target_stack[0]):
                # If they are the same, stack them
                target_stack.extend(self.cursor_stack)
                self.cursor_stack.clear()
            else:
                # Otherwise, swap them
                self.cursor_stack, self.hotbar_slots[slot_index] = target_stack, self.cursor_stack
        elif button == arcade.MOUSE_BUTTON_RIGHT:
            if self.cursor_stack and (not target_stack or self._get_entity_hash(target_stack[0]) == self._get_entity_hash(self.cursor_stack[0])):
                target_stack.append(self.cursor_stack.pop())
            elif not self.cursor_stack and target_stack:
                split_amount = math.ceil(len(target_stack) / 2)
                self.cursor_stack.extend(target_stack[split_amount:])
                del target_stack[split_amount:]

    def _handle_inventory_click(self, slot_index: int, button: int):
        grouped_items = self._get_grouped_items()
        item_stacks = list(grouped_items.values())
        if slot_index < len(item_stacks):
            source_stack = item_stacks[slot_index]
            if button == arcade.MOUSE_BUTTON_LEFT:
                # Check if both cursor and source stacks have items and are of the same type
                if self.cursor_stack and source_stack and self._get_entity_hash(self.cursor_stack[0]) == self._get_entity_hash(source_stack[0]):
                    # If same type, add cursor items to master list and clear cursor
                    self._master_item_list.extend(self.cursor_stack)
                    self.cursor_stack.clear()
                else:
                    # Otherwise, perform the swap
                    source_ids = {id(item) for item in source_stack}
                    self._master_item_list = [item for item in self._master_item_list if id(item) not in source_ids]
                    self._master_item_list.extend(self.cursor_stack)
                    self.cursor_stack = source_stack
            elif button == arcade.MOUSE_BUTTON_RIGHT:
                if not self.cursor_stack and source_stack:
                    split_amount = math.ceil(len(source_stack) / 2)
                    items_to_move = source_stack[:split_amount]
                    self.cursor_stack.extend(items_to_move)
                    for item in items_to_move:
                        self._master_item_list.remove(item)
        elif self.cursor_stack:
            if button == arcade.MOUSE_BUTTON_LEFT:
                self._master_item_list.extend(self.cursor_stack)
                self.cursor_stack.clear()
            elif button == arcade.MOUSE_BUTTON_RIGHT:
                if self.cursor_stack: self._master_item_list.append(self.cursor_stack.pop())
    def _get_grouped_items(self) -> dict:
        grouped = collections.defaultdict(list)
        checked_out_ids = {id(item) for stack in self.hotbar_slots for item in stack}
        if self.cursor_stack:
            checked_out_ids.update(id(item) for item in self.cursor_stack)
        for item in self._master_item_list:
            if id(item) not in checked_out_ids:
                grouped[self._get_entity_hash(item)].append(item)
        return grouped

    def _rebuild_visuals(self, screen_width: int, screen_height: int):
        """
        Clears and rebuilds all visual elements for the inventory and hotbar UI.
        """
        # 1. Initialize fresh lists to hold all visual components
        self._shape_list = arcade.shape_list.ShapeElementList()
        self._sprite_list = arcade.SpriteList()
        self._text_list = []
        self._clickable_areas = {}
        
        # --- Rebuild Hotbar ---
        # ----------------------
        
        # Calculate dimensions and starting position for the hotbar
        hotbar_width = (self.SLOT_SIZE * self.HOTBAR_SLOT_COUNT) + (self.SLOT_MARGIN * (self.HOTBAR_SLOT_COUNT - 1))
        hotbar_start_x = (screen_width / 2) - (hotbar_width / 2)
        hotbar_center_y = self.SLOT_SIZE / 2 + self.SLOT_MARGIN
        
        # Draw each slot in the hotbar
        for i in range(self.HOTBAR_SLOT_COUNT):
            # Calculate the center position of the current slot
            center_x = hotbar_start_x + (self.SLOT_SIZE / 2) + i * (self.SLOT_SIZE + self.SLOT_MARGIN)
            
            # Draw the slot background
            slot_bg = arcade.shape_list.create_rectangle_filled(center_x, hotbar_center_y, self.SLOT_SIZE, self.SLOT_SIZE, self.SLOT_BG_COLOR)
            self._shape_list.append(slot_bg)
            
            # Add a highlight if this slot is currently selected
            if i == self.selected_hotbar_slot:
                highlight_border = arcade.shape_list.create_rectangle_outline(center_x, hotbar_center_y, self.SLOT_SIZE, self.SLOT_SIZE, self.SLOT_HIGHLIGHT_COLOR, 2)
                self._shape_list.append(highlight_border)
                
            # Register the area for click detection
            left = center_x - self.SLOT_SIZE / 2
            bottom = hotbar_center_y - self.SLOT_SIZE / 2
            self._clickable_areas[("hotbar", i)] = (left, bottom, self.SLOT_SIZE, self.SLOT_SIZE)
            
            # Draw the item sprite and count if the slot is not empty
            stack = self.hotbar_slots[i]
            if stack:
                item, count = stack[0], len(stack)
                
                # Draw the item sprite
                texture_name = item.params.get("texture")
                if texture_name and texture_name in loaded_textures:
                    sprite = arcade.Sprite(loaded_textures[texture_name])
                    sprite.scale = (self.SLOT_SIZE * self.SPRITE_SCALE_FACTOR) / sprite.width
                    sprite.position = (center_x, hotbar_center_y)
                    self._sprite_list.append(sprite)
                    
                # Draw the stack count text if more than one item
                if count > 1:
                    text_x = center_x + self.SLOT_SIZE / 2 - 8
                    text_y = hotbar_center_y - self.SLOT_SIZE / 2 + 5
                    count_text = arcade.Text(str(count), text_x, text_y, self.TEXT_COLOR, self.FONT_SIZE, anchor_x="center")
                    self._text_list.append(count_text)

        # --- Rebuild Inventory Window (if open) ---
        # ------------------------------------------
        
        if self.is_open:
            item_stacks = list(self._get_grouped_items().values())
            
            # Determine the number of rows needed to display all items
            num_rows = self.INV_MIN_ROWS
            if item_stacks:
                num_rows = max(self.INV_MIN_ROWS, math.ceil(len(item_stacks) / self.INV_COLS))

            # Calculate inventory window dimensions and center
            window_width = (self.SLOT_SIZE * self.INV_COLS) + (self.SLOT_MARGIN * (self.INV_COLS + 1))
            window_height = (self.SLOT_SIZE * num_rows) + (self.SLOT_MARGIN * (num_rows + 1))
            win_center_x, win_center_y = screen_width / 2, screen_height / 2
            
            # Draw the background panel for the inventory
            panel = arcade.shape_list.create_rectangle_filled(win_center_x, win_center_y, window_width, window_height, self.INV_WINDOW_COLOR)
            self._shape_list.append(panel)
            
            # Calculate the starting position for the top-left slot
            inv_start_x = win_center_x - (window_width / 2) + self.SLOT_MARGIN + (self.SLOT_SIZE / 2)
            inv_start_y = win_center_y + (window_height / 2) - self.SLOT_MARGIN - (self.SLOT_SIZE / 2)
            
            # Draw the grid of inventory slots
            for i in range(num_rows * self.INV_COLS):
                row, col = divmod(i, self.INV_COLS)
                
                # Calculate the center of the current slot
                center_x = inv_start_x + col * (self.SLOT_SIZE + self.SLOT_MARGIN)
                center_y = inv_start_y - row * (self.SLOT_SIZE + self.SLOT_MARGIN)
                
                # Draw the slot background
                slot_bg = arcade.shape_list.create_rectangle_filled(center_x, center_y, self.SLOT_SIZE, self.SLOT_SIZE, self.SLOT_BG_COLOR)
                self._shape_list.append(slot_bg)
                
                # Register the area for click detection
                left = center_x - self.SLOT_SIZE / 2
                bottom = center_y - self.SLOT_SIZE / 2
                self._clickable_areas[("inventory", i)] = (left, bottom, self.SLOT_SIZE, self.SLOT_SIZE)
                
                # If there's an item for this slot, draw it
                if i < len(item_stacks):
                    item, count = item_stacks[i][0], len(item_stacks[i])
                    
                    # Draw the item sprite
                    texture_name = item.params.get("texture")
                    if texture_name and texture_name in loaded_textures:
                        sprite = arcade.Sprite(loaded_textures[texture_name])
                        sprite.scale = (self.SLOT_SIZE * self.SPRITE_SCALE_FACTOR) / sprite.width
                        sprite.position = (center_x, center_y)
                        self._sprite_list.append(sprite)
                        
                    # Draw the stack count text if more than one item
                    if count > 1:
                        text_x = center_x + self.SLOT_SIZE / 2 - 8
                        text_y = center_y - self.SLOT_SIZE / 2 + 5
                        count_text = arcade.Text(str(count), text_x, text_y, self.TEXT_COLOR, self.FONT_SIZE, anchor_x="center")
                        self._text_list.append(count_text)

        # 3. Flag that the visuals have been updated
        self._needs_rebuild = True
    def draw(self, screen_width, screen_height, mouse_x, mouse_y):
        if self._needs_rebuild: self._rebuild_visuals(screen_width, screen_height)
        self._shape_list.draw(); self._sprite_list.draw()
        for text_object in self._text_list: text_object.draw()
        
        if self.cursor_stack and self.cursor_sprite.texture:
            self.cursor_sprite.position = (mouse_x, mouse_y)
            self.cursor_sprite_list.draw()
            if len(self.cursor_stack) > 1:
                # CORRECTED: Use positional arguments for text, x, and y.
                cursor_count_text = arcade.Text(
                    str(len(self.cursor_stack)),
                    mouse_x + 15,
                    mouse_y - 15,
                    color=self.TEXT_COLOR,
                    font_size=self.FONT_SIZE,
                    anchor_x="center"
                )
                cursor_count_text.draw()

        if self.hovered_item_stack:
            item, name, desc = self.hovered_item_stack[0], self.hovered_item_stack[0].params.get("name", "Unknown"), self.hovered_item_stack[0].params.get("description", "")
            # This tooltip creation already uses the correct format
            text_obj = arcade.Text(f"{name}\n{desc}", 0, 0, self.TEXT_COLOR, self.FONT_SIZE, multiline=True, width=self.TOOLTIP_WIDTH)
            box_width, box_height = text_obj.content_width + 20, text_obj.content_height + 20
            box_x, box_y = mouse_x + box_width/2 + 10, mouse_y - box_height/2 - 10
            tooltip_shapes = arcade.shape_list.ShapeElementList(); tooltip_bg = arcade.shape_list.create_rectangle_filled(box_x, box_y, box_width, box_height, self.TOOLTIP_COLOR); tooltip_shapes.append(tooltip_bg); tooltip_shapes.draw()
            text_obj.position = (box_x - box_width/2 + 10, box_y + box_height/2 - text_obj.content_height/2 + self.FONT_SIZE/2); text_obj.draw()

--------------------
client\game\music.py
import arcade
from pathlib import Path
from loader.content import get_object_properties as get_content

class MusicPlayer:
    def __init__(self):
        self.current_song = None
        self.player = None
        self.is_playing = False
        self.volume = 0.5  # Default volume (0.0 to 1.0)
        self.looping = True  # Default to looping
        
    def load_song(self):
        """Load a music file"""
        # Get the full path to the music file
        music_path = Path(__file__).parent.parent.parent / "assets" / get_content("background_music_1")['file']
        print(f"Loading music from: {music_path}")
        
        try:
            self.current_song = arcade.load_sound(str(music_path))
            print(f"Loaded sound: {self.current_song}")
            self.is_playing = False  # Reset playing state
        except Exception as e:
            print(f"Error loading music: {e}")
            self.current_song = None
            self.is_playing = False

    def play(self):
        """Start playing the current song"""
        if self.current_song and not self.is_playing:
            print(f"Playing music with volume: {self.volume}")
            self.player = arcade.play_sound(self.current_song, volume=self.volume, loop=self.looping)
            self.is_playing = True

    def toggle_play_pause(self):
        """Toggle between play and pause"""
        if self.player:
            if self.is_playing:
                arcade.stop_sound(self.player)
                self.is_playing = False
            else:
                self.player = arcade.play_sound(self.current_song, volume=self.volume, looping=self.looping)
                self.is_playing = True

    def set_volume(self, volume: float):
        """Set the volume (0.0 to 1.0)"""
        if 0.0 <= volume <= 1.0:
            self.volume = volume
            if self.player:
                arcade.set_volume(self.player, self.volume)

    def stop(self):
        """Stop playing the music"""
        if self.player:
            arcade.stop_sound(self.player)
            self.player = None
            self.is_playing = False
--------------------
client\game\player.py
import arcade
from entity.entity import Entity
from render.renderer import TILE_SIZE
from loader.content import get_object_properties as get_content
from networking.main import get_tile_map, entities

class Player:
    def __init__(self):
        self.entity = None
        # self.x and self.y are now read-only mirrors of the sprite's position
        self.x = 0
        self.y = 0
        self.speed = 250
        self.keys = {'W': False, 'A': False, 'S': False, 'D': False}
        self.wall_list = arcade.SpriteList()

    def get_position(self):
        return self.x, self.y

    def try_link_entity(self) -> bool:
        """Finds the player's entity once the renderer has created its sprite."""
        if self.entity: return True
        
        for entity in entities.values():
            if entity.proto == 'player' and entity.sprite:
                self.entity = entity
                print("✅ Player entity linked!")
                return True
        return False

    def build_static_wall_list(self):
        print("Player: Building static wall list...")
        self.wall_list = arcade.SpriteList()
        
        all_tiles = get_tile_map().get('layout', {}).get('tiles', [])
        for tile in all_tiles:
            tile_props = get_content(tile.get('tile'))
            if tile_props and tile_props.get('wall', False):
                wall = arcade.SpriteSolidColor(int(TILE_SIZE), int(TILE_SIZE), arcade.color.RED)
                wall.position = (tile['x'] * TILE_SIZE + TILE_SIZE / 2, tile['y'] * TILE_SIZE + TILE_SIZE / 2)
                self.wall_list.append(wall)

        if entities:
            for entity in entities.values():
                if entity.id == self.entity.id or not entity.sprite: continue
                entity_props = get_content(entity.proto) or {}
                if entity_props.get('wall', False):
                    self.wall_list.append(entity.sprite)
        
        print(f"Player: Wall list created with {len(self.wall_list)} objects.")

    def on_key_press_player(self, symbol, modifiers):
        if symbol == arcade.key.F7:
            from render.renderer import toggle_hitbox_drawing
            toggle_hitbox_drawing()
        
        if symbol == arcade.key.W: self.keys['W'] = True
        if symbol == arcade.key.A: self.keys['A'] = True
        if symbol == arcade.key.S: self.keys['S'] = True
        if symbol == arcade.key.D: self.keys['D'] = True

    def on_key_release_player(self, symbol, modifiers):
        if symbol == arcade.key.W: self.keys['W'] = False
        if symbol == arcade.key.A: self.keys['A'] = False
        if symbol == arcade.key.S: self.keys['S'] = False
        if symbol == arcade.key.D: self.keys['D'] = False
    
    def on_update(self, delta_time: float):
        if not self.try_link_entity(): return
        
        if not self.wall_list:
            self.build_static_wall_list()

        self.process_movement(delta_time)

        # After all physics, update the read-only coordinates
        self.x = self.entity.sprite.center_x
        self.y = self.entity.sprite.center_y
    def process_movement(self, delta_time: float):
        if not self.entity or not self.entity.sprite: return
        vx = 0; vy = 0 
        if self.keys['W']: vy += self.speed
        if self.keys['S']: vy -= self.speed
        if self.keys['A']: vx -= self.speed
        if self.keys['D']: vx += self.speed
        if vx != 0 and vy != 0:
            vx *= 0.7071; vy *= 0.7071
        
        # Move the sprite directly
        self.entity.sprite.center_x += vx * delta_time
        for wall in arcade.check_for_collision_with_list(self.entity.sprite, self.wall_list):
            if vx > 0: self.entity.sprite.right = wall.left
            elif vx < 0: self.entity.sprite.left = wall.right

        self.entity.sprite.center_y += vy * delta_time
        for wall in arcade.check_for_collision_with_list(self.entity.sprite, self.wall_list):
            if vy > 0: self.entity.sprite.top = wall.bottom
            elif vy < 0: self.entity.sprite.bottom = wall.top

        # Sync the entity's grid coordinates from the sprite's final position
        self.entity.x = self.entity.sprite.center_x / TILE_SIZE
        self.entity.y = self.entity.sprite.center_y / TILE_SIZE
--------------------
client\loader\content.py
import yaml
from pathlib import Path
import os
import sys

# Cache for storing previously queried objects
_content_cache = {}

def get_object_properties(obj_name):
    """Get properties for any object by its exact name, regardless of where it's located in the content structure"""
    # Check cache first
    if obj_name in _content_cache:
        return _content_cache[obj_name]

    def search_dict(d, obj_name):
        """Recursively search through a dictionary for the object name"""
        if not isinstance(d, dict):
            return None
            
        # Check if the object is directly in this dictionary
        if obj_name in d:
            return d[obj_name]
            
        # Recursively search through all values
        for value in d.values():
            if isinstance(value, dict):
                result = search_dict(value, obj_name)
                if result is not None:
                    return result
        return None
    
    # Search through all loaded content
    for data in yml_content.values():
        if isinstance(data, dict):
            result = search_dict(data, obj_name)
            if result is not None:
                # Store in cache before returning
                cached_result = {
                    'name': obj_name,
                    **result
                }
                _content_cache[obj_name] = cached_result
                return cached_result
    return None

# Clear cache when content is reloaded
def clear_content_cache():
    """Clear the content cache when content is reloaded"""
    _content_cache.clear()

def get_content_dir():
    # Get the base directory (works for both development and executable)
    if getattr(sys, 'frozen', False):
        # Running as executable
        base_path = sys._MEIPASS
    else:
        # Running in development mode
        base_path = Path(__file__).parent.parent.parent
    
    return Path(base_path) / "assets" / "content"

yml_content = {}

def loader():
    content_dir = get_content_dir()
    if not content_dir.exists():
        raise FileNotFoundError(f"Content directory {content_dir} not found")
    yml_content.clear()
    for file in content_dir.glob("*.yml"):
        try:
            with file.open("r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if data is not None:
                    yml_content[file.stem] = data
        except Exception as e:
            print(f"Error loading {file}: {str(e)}")

    # Immediately remove the local map content after loading.
    # The client will wait for the map from the server instead.
    if "map" in yml_content:
        del yml_content["map"]

    return yml_content

def load_content():
    #print(loader())
    return loader()

def get_objects_by_property(prop_key: str, prop_value) -> list:
    found_objects = []
    
    def search_recursive(d):
        for key, value in d.items():
            if isinstance(value, dict):
                # Check if the dictionary itself is the object we want
                if value.get(prop_key) == prop_value:
                    found_objects.append(value)
                # Continue searching deeper
                search_recursive(value)

    for category in yml_content.values():
        if isinstance(category, dict):
            search_recursive(category)
            
    return found_objects
--------------------
client\networking\main.py
import socket
import threading
import json

isConnectedToServer = False
tile_map = {}
entities = {}



def receive_messages(sock):
    global tile_map
    global entities
    while True:
        try:
            data = sock.recv(65536)
            if not data:
                print("Disconnected from server")
                break
            #print(f"Received: {data.decode()}")
            message = json.loads(data.decode())
            if message['type'] == 'response':
                if message['data']['type'] == 'entities':
                    entities = message['data']['data']
                    #print(f"recieved entities {entities}")
                    pass
                elif message['data']['type'] == 'map':
                    tile_map = message['data']['data']
                    #print(f"recieved map {tile_map}")
                    pass
            
        except ConnectionError:
            print("Connection lost")
            break

def get_tile_map():
    return tile_map

def get_entities():
    return entities


def send_messages(socket: socket.socket,player):
    s = socket
    message = {
        "type": "update",
        "data": {
            "type": "player",
            "data": {
                "x": player.x,
                "y": player.y
            }
        }
    }
    s.sendall((json.dumps(message) + '\n').encode())  # Convert entire message to JSON once
def start_client(player, host='127.0.0.1', port=5555):
    global isConnectedToServer
    isConnectedToServer = False
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((host, port))
            print(f"Connected to {host}:{port}")
            isConnectedToServer = True
            
            # Start receiving messages in a separate thread
            recv_thread = threading.Thread(target=receive_messages, args=(s,), daemon=True)
            recv_thread.start()
            message = {
                "type": "join",
                "data": {
                    "type": "player",
                    "data": {
                        "x": player.x,
                        "y": player.y
                    }
                }
            }
            s.sendall((json.dumps(message) + '\n').encode())  # Convert entire message to JSON once
            # Send messages from user input
            while True:
                send_messages(s,player)
        except ConnectionRefusedError:
            print(f"Could not connect to {host}:{port}")
        except KeyboardInterrupt:
            print("\nDisconnecting...")
        except Exception as e:
            print(f"Error: {e}")

if __name__ == '__main__':
    start_client()
--------------------
client\render\renderer.py
import arcade
import os
import time
from typing import Dict, List, Tuple, Set, Optional
from loader.content import get_object_properties as get_content
from dataclasses import dataclass
from networking.main import get_tile_map, entities

_debug_draw_hitboxes = False

# Constants
TILE_SIZE = 48
VIEWPORT_PADDING = 2  # Slightly increased padding to reduce updates when moving
TEXTURE_SCALE = TILE_SIZE / 64  # Assuming 32x32 textures by default

# Performance tracking
_last_update_time = 0
_update_interval = 0.1  # Update viewport every 100ms

# Game state
loaded_textures: Dict[str, arcade.Texture] = {}
active_sprites: arcade.SpriteList = arcade.SpriteList(use_spatial_hash=True)
tile_sprites: Dict[Tuple[int, int], arcade.Sprite] = {}
entity_sprites: Dict[str, arcade.Sprite] = {} # New: For storing entity sprites
player_sprite: Optional[arcade.Sprite] = None
unique_textures = set()
_initialized = False
_last_viewport = None  # Cache the last viewport to avoid unnecessary updates
_visible_tiles = set()  # Track currently visible tiles
_last_camera_pos = (0, 0)  # Track last camera position

@dataclass
class Viewport:
    left: float
    right: float
    bottom: float
    top: float
    width: float
    height: float

    @classmethod
    def from_camera(cls, camera_pos: Tuple[float, float], width: int, height: int) -> 'Viewport':
        """Create a viewport from camera position and window dimensions."""
        half_width = width / 2
        half_height = height / 2
        return cls(
            left=camera_pos[0] - half_width,
            right=camera_pos[0] + half_width,
            bottom=camera_pos[1] - half_height,
            top=camera_pos[1] + half_height,
            width=width,
            height=height
        )

def preload_textures() -> None:
    """Preload all textures used in the game."""
    unique_textures.add("ui/trans1.png")
    unique_textures.add("ui/trans1024.png")
    
    # Get all unique tile textures if map is available
    tile_map = get_tile_map()
    if 'layout' in tile_map and 'tiles' in tile_map['layout']:
        for tile in tile_map['layout']['tiles']:
            try:
                tile_props = get_content(tile['tile'])
                if tile_props and 'texture' in tile_props:
                    unique_textures.add(tile_props["texture"])
            except (KeyError, TypeError):
                continue
    else:
        print('skill issue')

    # Get all unique entity textures
    if entities:
        for entity in entities.values():
            try:
                entity_props = get_content(entity.proto)
                if entity_props and 'texture' in entity_props:
                    unique_textures.add(entity_props["texture"])
            except (KeyError, TypeError):
                continue

    # Get player texture (can be redundant if player is in entities, but safe)
    try:
        player_props = get_content('player')
        if player_props and 'texture' in player_props:
            unique_textures.add(player_props["texture"])
    except (KeyError, TypeError):
        pass
    
    # Load all textures
    for texture_name in unique_textures:
        if texture_name and texture_name not in loaded_textures:
            try:
                loaded_textures[texture_name] = arcade.load_texture(f"assets/textures/{texture_name}")
            except (FileNotFoundError, arcade.resources.resource.ResourceError):
                print(f"Warning: Could not load texture: {texture_name}")

def init_map() -> None:
    """Initialize the map and create all tile sprites."""
    global tile_sprites
    
    tile_sprites.clear()
    
    tile_map = get_tile_map()

    # Check if map data is available
    if 'layout' not in tile_map or 'tiles' not in tile_map['layout']:
        print("Warning: Map data not available for initialization")
        print(tile_map)
        raise RuntimeError("Map data not available for initialization")
    
    map_data = tile_map
    
    for tile in map_data['layout']['tiles']:
        try:
            tile_name = tile.get('tile')
            if not tile_name:
                continue
                
            tile_props = get_content(tile_name)
            if not tile_props or 'texture' not in tile_props:
                continue
                
            texture_name = tile_props["texture"]
            if texture_name not in loaded_textures:
                continue
            
            texture = loaded_textures[texture_name]
            
            # Create sprite
            sprite = arcade.Sprite(texture)
            sprite.scale = TILE_SIZE / max(texture.width, texture.height)
            sprite.position = (round(tile['x'] * TILE_SIZE), round(tile['y'] * TILE_SIZE))
            
            # Store sprite with its grid position as key
            tile_sprites[(tile['x'], tile['y'])] = sprite
            
        except (KeyError, TypeError) as e:
            print(f"Warning: Error processing tile at ({tile.get('x')}, {tile.get('y')}): {e}")
            continue

def init_entities() -> None:
    """Initialize sprites for ALL entities, including the player."""
    global entity_sprites
    entity_sprites.clear()
    
    if not entities: return

    for entity_id, entity in entities.items():
        # Only process entities that should be drawn
        if entity.draw:
            try:
                props = get_content(entity.proto)
                if not props or 'texture' not in props: continue
                
                texture_name = props["texture"]
                if texture_name not in loaded_textures: continue
                
                texture = loaded_textures[texture_name]
                sprite = arcade.Sprite(texture, hit_box_algorithm="Detailed")

                if entity.proto == 'player':
                    sprite.width = TILE_SIZE - 4
                    sprite.height = TILE_SIZE - 4
                else:
                    sprite.scale = TILE_SIZE / max(texture.width, texture.height)

                sprite.position = ((entity.x * TILE_SIZE) + (TILE_SIZE / 2), (entity.y * TILE_SIZE) + (TILE_SIZE / 2))
                sprite.angle = entity.rot
                
                entity_sprites[entity_id] = sprite
                entity.sprite = sprite
            except (KeyError, TypeError) as e:
                print(f"Warning: Error initializing sprite for entity '{entity_id}': {e}")

def update_entity_sprites() -> None:
    """Update positions and rotations of all drawn entities."""
    if not entities:
        return
        
    for entity_id, entity in entities.items():
        # Only process entities that should be drawn
        if entity.proto != 'player' and entity.draw and entity_id in entity_sprites:
            sprite = entity_sprites[entity_id]
            sprite.position = ((entity.x * TILE_SIZE) + (TILE_SIZE / 2), (entity.y * TILE_SIZE) + (TILE_SIZE / 2))
            sprite.angle = entity.rot
def should_update_viewport(viewport: 'Viewport') -> bool:
    """Check if we should update the viewport based on movement."""
    global _last_update_time, _last_viewport
    
    current_time = time.time()
    if current_time - _last_update_time < _update_interval and _last_viewport:
        # Check if viewport has moved significantly
        dx = abs(viewport.left - _last_viewport.left)
        dy = abs(viewport.bottom - _last_viewport.bottom)
        if dx < TILE_SIZE and dy < TILE_SIZE:
            return False
    
    _last_update_time = current_time
    _last_viewport = viewport
    return True

def update_visible_tiles(viewport: 'Viewport') -> None:
    """Update which tiles and entities are visible based on the current viewport."""
    global active_sprites, _visible_tiles, _last_camera_pos
    
    update_entity_sprites()

    if not should_update_viewport(viewport):
        return
    
    current_camera_pos = (viewport.left, viewport.bottom)
    _last_camera_pos = current_camera_pos
    
    min_x_tile = int((viewport.left - TILE_SIZE * VIEWPORT_PADDING) // TILE_SIZE)
    max_x_tile = int((viewport.right + TILE_SIZE * VIEWPORT_PADDING) // TILE_SIZE) + 1
    min_y_tile = int((viewport.bottom - TILE_SIZE * VIEWPORT_PADDING) // TILE_SIZE)
    max_y_tile = int((viewport.top + TILE_SIZE * VIEWPORT_PADDING) // TILE_SIZE) + 1
    
    visible_sprites = []
    
    if tile_sprites:
        for y in range(min_y_tile, max_y_tile + 1):
            for x in range(min_x_tile, max_x_tile + 1):
                sprite = tile_sprites.get((x, y))
                if sprite:
                    visible_sprites.append(sprite)

    # Add visible entities to the list, checking the 'draw' flag
    # Note: This loop is changed to iterate over 'entities' to access the flag.
    if entities:
        min_x_px = viewport.left - TILE_SIZE
        max_x_px = viewport.right + TILE_SIZE
        min_y_px = viewport.bottom - TILE_SIZE
        max_y_px = viewport.top + TILE_SIZE
        
        for entity in entities.values():
            if entity.draw and entity.sprite:
                sprite = entity.sprite
                if (min_x_px < sprite.center_x < max_x_px and
                    min_y_px < sprite.center_y < max_y_px):
                    visible_sprites.append(sprite)
    
    active_sprites.clear()
    active_sprites.extend(visible_sprites)

def draw_map(window) -> None:
    """Update and draw the visible portion of the map."""
    
    # Only update viewport if window size changed or first run
    if not hasattr(draw_map, '_last_size') or draw_map._last_size != (window.width, window.height):
        draw_map._last_size = (window.width, window.height)
        viewport = Viewport.from_camera(
            (window.camera.position[0], window.camera.position[1]),
            window.width,
            window.height
        )
        update_visible_tiles(viewport)
    else:
        # Reuse existing viewport if only camera position changed
        viewport = Viewport.from_camera(
            (window.camera.position[0], window.camera.position[1]),
            window.width,
            window.height
        )
        update_visible_tiles(viewport)

def update_camera_position(camera_x: float, camera_y: float, player) -> None:
    """Update camera and sprite positions."""
    try:
        if hasattr(player, 'sprite') and player.sprite is not None:
            # Update player sprite position
            player.sprite.position = (player.x, player.y)
            
            # Update global player sprite reference
            global player_sprite
            player_sprite = player.sprite
    except Exception as e:
        print(f"Error updating camera position: {e}")

# Cache the text object for better performance
_debug_text = None

def toggle_hitbox_drawing():
    """Flips the debug flag for drawing hitboxes."""
    global _debug_draw_hitboxes
    _debug_draw_hitboxes = not _debug_draw_hitboxes
    print(f"Hitbox drawing {'ENABLED' if _debug_draw_hitboxes else 'DISABLED'}")

def draw() -> None:
    """Draw all active sprites."""
    global _debug_text
    
    # Draw all sprites in one batch
    if active_sprites:
        active_sprites.draw(
            filter=None, 
            pixelated=True
        )
        
        # --- THIS IS THE FIX ---
        # If the debug flag is on, draw the hitboxes separately.
        if _debug_draw_hitboxes:
            active_sprites.draw_hit_boxes(color=arcade.color.BLUE, line_thickness=2)
    
    # Only update debug text periodically
    current_time = time.time()
    if not hasattr(draw, '_last_debug_update') or current_time - draw._last_debug_update > 0.5:
        draw._last_debug_update = current_time
        if not _debug_text:
            _debug_text = arcade.Text(
                f"Sprites: {len(active_sprites)}",
                10, 10,
                arcade.color.WHITE, 12
            )
        else:
            _debug_text.text = f"Sprites: {len(active_sprites)}"
    
    if _debug_text:
        _debug_text.draw()
def draw_player(player) -> None:
    """Initialize or update the player sprite."""
    global player_sprite
    
    try:
        if not hasattr(player, 'sprite') or player.sprite is None:
            tile_props = get_content('player')
            if not tile_props or 'texture' not in tile_props:
                print("Warning: Could not get player texture properties")
                return
                
            texture_name = tile_props["texture"]
            if texture_name not in loaded_textures:
                print(f"Warning: Player texture '{texture_name}' not loaded")
                return
                
            texture = loaded_textures[texture_name]
            
            # --- THIS IS THE FIX ---
            # Use the "Detailed" algorithm to create a hitbox that fits the visible pixels, ignoring transparency.
            player.sprite = arcade.Sprite(texture, hit_box_algorithm="Detailed")
            
            player.sprite.scale = TILE_SIZE / max(texture.width, texture.height)
            player_sprite = player.sprite
        
        # This part remains the same
        if hasattr(player, 'sprite') and player.sprite is not None:
            player.sprite.position = (player.x, player.y)
    except Exception as e:
        print(f"Error initializing/updating player sprite: {e}")
# Initialize the renderer
_initialized = False

def initialize_renderer() -> None:
    """Initialize the renderer. Must be called after content is loaded."""
    global _initialized
    if not _initialized:
        preload_textures()
        init_map()
        init_entities() # Initialize entity sprites
        _initialized = True
--------------------
